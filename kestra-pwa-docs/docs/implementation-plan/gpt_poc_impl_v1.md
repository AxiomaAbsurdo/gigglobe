---
id: gpt_poc_impl_v1
title: GPT POC Implementation Plan
sidebar_label: GPT POC v1
slug: /implementation-plan/gpt_poc_v1
---

# Orchestrating PWA Job Matching Workflows with Kestra

## Introduction and Background

We are building a **Progressive Web App (PWA)** using Vite.js (TypeScript) and the Vite PWA plugin, aimed at matching traveling workers with temporary jobs. The application uses **Auth0** for authentication and defines two user roles: **Job Seekers** (traveling workers) and **Job Publishers** (employers posting temporary jobs). Key features include user registration and profile management (skills, availability), job postings, automated skill/availability matching, and job application management.

To power the backend workflows for these features, we can leverage **Kestra.io**, an open-source workflow orchestration platform. **Kestra** allows us to define backend processes (workflows) in a declarative YAML format and trigger them in response to events or on schedules. It is an event-driven orchestrator supporting both scheduled and real-time triggers, enabling us to automate each step of the job matching business logic. Crucially, Kestra’s rich plugin ecosystem provides integrations for databases, APIs, messaging, and more. In the context of our PWA, Kestra can coordinate complex multi-step processes (like matching and notifications) while the frontend remains focused on user interaction.

Below, we outline how Kestra can handle major workflows for both job seekers and publishers, how it automates notifications, and how it integrates with Auth0 and the Vite PWA. We then present a two-week proof-of-concept plan and a summary table of responsibilities between the frontend and Kestra (backend).

## Job Seeker Workflows

### 1. User Registration Workflow

**Trigger:** When a new user signs up via Auth0, an Auth0 Action (post-registration hook) sends user data to a Kestra webhook endpoint. This includes the user's Auth0 ID, email, name, and role (job seeker or publisher).

**Kestra Flow Tasks:**
- **Create User Profile:** A task using the JDBC plugin will run an SQL INSERT to create a user profile record in our database. This stores the Auth0 user ID, email, name, and role.
- **Send Welcome Email:** Using Kestra's email plugin (MailSend), we send a personalized welcome email to the user, with content tailored to their role (job seeker vs. publisher).

**Result:** The user receives a welcome email, and our database now has a profile entry. This workflow runs asynchronously after signup, so it doesn't delay the front-end sign-up process (Auth0 handles immediate user creation and login). Auth0 integration ensures we know the user's ID and email, while Kestra handles the downstream processing.

### 2. Profile and Availability Submission Workflow

Job seekers will update their profiles with **skills** and set their **availability** (dates or locations where they can work). These actions in the PWA should trigger backend workflows to record the updates and possibly initiate job matching logic.

**Trigger:** When a user submits or updates their availability or skills via the PWA, the front-end can send an authenticated request to a backend endpoint. This could be a direct call to a Kestra **webhook trigger URL** (including the secret key), or a call to a small Node/Express backend that in turn invokes the Kestra flow (via Kestra’s REST API or webhook). In either case, the event is captured by Kestra as an external trigger. The request payload would include the user’s identifier (from Auth0 JWT) and the new availability/skill data.
**Kestra Flow Tasks:** The **Profile Update** flow can handle both skill updates and availability:
**Update Database:** A task (using the JDBC plugin) will run an SQL UPDATE to store the user’s new skill set or availability in the database. For instance, using the same Query task type, we can update the “skills” field or an “availability” table for that user.
**Matching Check (Optional):** After updating the data, the flow can perform an **automated matching query** to see if there are any open jobs that fit the user’s new profile or upcoming availability. This could be done with a database query (e.g., find all active jobs where required_skill IN (user.skills) and dates overlap the user’s availability). The Kestra flow can execute such a query and retrieve results. If matches are found, we could branch the workflow to handle notifications:
**Notify User of Matching Jobs:** Kestra can send an email or push notification listing the top matching job postings. (For a POC, an email via MailSend or a simple log output can be used to verify this step.)
**Or, Update Candidate Pool:** Alternatively, instead of immediately notifying the user, the flow might add this user to candidate lists for those jobs. For example, for each matched job, call another Kestra flow or task to record that this user is a potential candidate (e.g., update a “candidate pool” table linking the job and user).
If no immediate matching is needed on profile update, we can simply conclude the flow after updating the database. (The primary matching is typically triggered by job postings, described next.)
**Result:** The user’s profile info is consistently stored and up-to-date in the backend. If configured, the user might get proactive alerts about existing job opportunities that match their new skills or availability. This keeps users engaged and informed about relevant jobs without manual searching. (In a full implementation, notifications to the user could also be deferred to a scheduled daily run or handled on the job-posting side to avoid spamming on every profile tweak – but for the POC we can demonstrate the concept with a direct trigger.)
## Publisher-Side Workflows

On the publisher side, the core workflows revolve around posting new jobs, automatically finding suitable candidates, and managing incoming applications. Kestra shines in automating the **job matching** process as soon as a job is posted, and coordinating communication when applications occur.

### 3. Job Posting & Automatic Matching Workflow

When a publisher posts a new job via the PWA, we want to automatically match that job to available, qualified seekers and generate a **candidate pool**. In a traditional app this might require complex backend code, but with Kestra we can declaratively define this process as a workflow triggered by the posting event.

**Trigger:** The front-end job posting form submission triggers a call to the backend (including the job details and the identity of the publisher). For the POC, this could be a direct POST to a Kestra webhook trigger URL carrying the job data in trigger.body. (In production, likely the PWA calls a secure API endpoint on our server, which then initiates the Kestra flow with appropriate authentication. We can protect the Kestra webhook by a secret key and also by ensuring only our server or trusted client calls it.)
**Kestra Flow Tasks:** The **Job Posting flow** will orchestrate the following steps:
1. **Record the Job Posting:** Insert the new job into the database. Using a JDBC Query task, we execute an SQL INSERT for the job (with details like location, required skills, dates, etc.). This makes the job available for queries by other flows or future operations. 2. **Find Matching Candidates:** Next, use a **Query task** to search the user database for candidates who meet the job criteria (e.g., users whose skill set matches the job’s required skill and who have indicated availability overlapping the job period). The Kestra JDBC plugin allows custom SQL, so we can join user skill and availability tables against the job requirements to get a list of user IDs or profiles that qualify. The query results are accessible to the flow as outputs, which we can iterate over or use in the next steps. 3. **Generate Candidate Pool:** We have a few options at this point:

*Store the candidate list:* We could update a **“candidate\_pool” table** linking the new job to the matched user IDs. This could be done with an INSERT for each candidate (possibly via a loop of Query tasks or a single batch insert if supported). Storing the pool allows the publisher’s front-end to fetch the list of suggested candidates when viewing the job posting.
*Immediate notifications to candidates:* Optionally, the flow can send out notifications to each matched **job seeker**. For example, a sub-task can loop through the matched user emails and send a standardized message: “A new job **** matching your skills is available.” Using Kestra’s **Email/SMS tasks**, this can be done in parallel or sequentially. (The POC can demonstrate one channel, e.g., send one email or log output per candidate to simulate this.) This step *alerts seekers* promptly, which can speed up applications.
*Notify the Publisher:* After processing candidates, the flow can also inform the job publisher that matching candidates have been identified. This could be an email summary: “Your job **X** has been posted. We found **N** potential candidates who were notified.” The MailSend task can compile the list of candidates (perhaps using templating in the email content to list names or numbers).
4. **(Optional) Parallelization and Conditions:** Kestra workflows support running tasks sequentially or in parallel, and can include conditional logic. For instance, sending notifications to multiple candidates could be done in parallel branches, or we might include a condition like “if no candidates found, skip notification tasks.” In YAML, we can define such branching, but for a simple POC, sequential steps are sufficient. * **Result:** As soon as a job is posted, the backend workflow automatically performs matching. The output is a **candidate pool** (stored in DB) and possibly real-time notifications dispatched to interested candidates. From the **publisher’s perspective**, the heavy lifting of sourcing candidates is done instantaneously – when they next view the job in the PWA, they could see the list of suggested candidates (fetched from the DB). Additionally, the publisher gets confirmation (e.g., via email) that the job was processed and candidates notified. This showcases how Kestra automates business logic that would otherwise require custom code and cron jobs.

### 4. Job Application Workflow

When a job seeker decides to apply for a job, we need to record the application and notify the publisher. This workflow handles the application process.

**Trigger:** The job seeker clicks "Apply" on a job listing in the PWA. The frontend sends an authenticated request to a Kestra webhook (or API endpoint) with the job ID, user ID, and possibly a short message or note.

**Kestra Flow Tasks:**
- **Record Application:** Using the JDBC plugin, insert a record into an "applications" table linking the job ID, user ID, timestamp, and any additional data (like a cover message).
- **Retrieve Applicant Details:** Query the database to get the applicant's profile information (name, skills, etc.) to include in the notification.
- **Notify Job Publisher:** Send a notification to the job publisher that a new candidate has applied. Likely an email to the publisher's address (retrieved via a join or a prior step to look up publisher info). The email can contain applicant details (name, contact) and a link or instruction to review the application in the PWA. (If internal team communication is needed, a Slack message via Kestra's Slack plugin could be used, but email is most relevant to an external publisher user.)
- **Confirm to Applicant:** Optionally, send a confirmation email to the job seeker confirming their application was received and providing any next steps.

**Result:** The application is recorded and the relevant parties are informed. The publisher can then follow up outside the system (or we could have further workflows for scheduling interviews, etc., but that's beyond our current scope). Importantly, Kestra has taken care of ensuring the database and notifications are handled transactionally as part of the workflow, reducing the chance of missed emails or stale data.

## Automated Notifications and Messaging

**Automating notifications** is a critical aspect of our platform – users should be promptly informed of new matches, and publishers about applications or other events. Kestra provides built-in support for sending notifications via various channels, which we can plug into our workflows wherever needed.

**Email Notifications:** As described above, we can use the MailSend task for SMTP emails or the SendGridMailSend for SendGrid integration. These tasks allow specifying recipients (to), subject, and content (plain text or HTML) with template variables. In our POC, email is a straightforward way to demonstrate notifications (e.g., welcome emails, match alerts, application notices). The Kestra documentation provides examples of how to configure these tasks with credentials and dynamic content.

**SMS Notifications (Optional):** For urgent notifications (e.g., "A new job matching your skills was just posted!"), we could use Kestra's Twilio integration to send SMS messages. The TwilioSms task type allows sending text messages with similar configuration to emails. While not essential for the POC, this demonstrates how easily we can add channels.

**In-App Notifications:** While not a direct Kestra responsibility, the results of Kestra workflows can be used by the PWA to show in-app alerts. For instance, after a matching flow runs, the frontend could query an endpoint to get any "new matches" for the current user and display them. This would rely on data written by the workflow (in a database or cache). Thus, Kestra indirectly enables in-app notifications by preparing the data. Real-time integration (like WebSockets or push) can be added later; for the POC, simple polling of updated data or reliance on emails is acceptable.

**Scheduled Notifications:** Beyond event-triggered notifications, Kestra can also handle scheduled notifications using its Schedule trigger type. For example, we could create a daily digest flow that runs every morning to notify job seekers of new matching opportunities posted in the last 24 hours. This demonstrates Kestra's ability to combine time-based and data-driven processes.

Overall, Kestra's notification plugins allow us to **insert communication steps directly into business workflows**. This tight integration means that when a match is found, the same orchestrator that did the matching can immediately trigger the message to the user, closing the loop automatically. By defining these in YAML, we avoid writing boilerplate code to call external APIs for email/SMS – Kestra handles it with one declarative task. For example, sending an approval request via Slack in a business process is shown in Kestra's blueprints, which is analogous to how we send job match alerts via email or SMS.

## Integration with Auth0 and Frontend Events

Seamless integration between the **Vite PWA frontend**, **Auth0 authentication**, and **Kestra backend** workflows is crucial. We address this by combining Auth0’s identity capabilities with Kestra’s event triggers:

### Secure Triggering via Webhooks

Kestra supports creating unique **webhook triggers** for flows, identified by URLs containing the namespace, flow ID, and a secret key. For this project, we will configure webhook triggers for key workflows such as registration, profile updates, job postings, and applications. The PWA or an intermediate server will call these URLs to initiate the workflows. The secret key in the URL, combined with HTTPS, ensures security by making the URL unguessable. If needed, the secret key can be regenerated or revoked.

To handle cross-origin requests, we may need to enable CORS or route calls through a backend server if the PWA is hosted on a different domain. For additional security, requests to Kestra can include an `Authorization: Bearer <token>` header containing a JWT issued by Auth0. While Kestra’s webhook trigger does not natively validate JWTs, we can add a preliminary task in the flow to verify the token by calling Auth0’s `/userinfo` or introspection endpoint using an HTTP task. However, for the proof of concept (POC), relying on the webhook’s secret key should suffice.

### Auth0 Actions to Kestra

Auth0 **Actions** provide a powerful mechanism to react to authentication events. In this project, we will use a **Post-Registration Action** to send a request to Kestra with the new user’s details upon sign-up. This ensures that the Kestra registration flow is triggered automatically as soon as a user is created in Auth0, without requiring manual intervention.

While the POC focuses on post-registration, other Auth0 triggers, such as post-login, could be utilized in the future. For example, a post-login action could log user activity or trigger a workflow to recommend jobs based on recent activity. These actions could also call Kestra flows, further integrating Auth0’s lifecycle with our backend workflows.

### Frontend Event Triggers

For user-initiated events such as availability updates, job postings, or job applications, the PWA will send requests to backend endpoints. In a minimal architecture, Kestra itself can act as the backend for these workflows. The PWA can directly call Kestra’s REST API endpoints or use webhook triggers to start flows with the required inputs.

If additional processing or security is needed, a lightweight Node.js server can act as an intermediary. This server, protected by Auth0 JWT validation, can receive requests from the PWA and invoke the appropriate Kestra flow via REST API. In a production environment, Kestra’s Enterprise version supports OpenID Connect authentication, allowing deeper integration with Auth0 as an identity provider for accessing Kestra APIs or UI. For the POC, simpler approaches such as open webhooks or a single API token will be sufficient.

### Passing Data and Context

The PWA will pass user-entered data (e.g., availability, job details) in the body or query parameters of webhook calls. Kestra’s trigger context makes this data accessible within the flow (e.g., `{{ trigger.body.someField }}`). Flows can define input schemas to validate and process this data. For example, a job-posting flow might accept job details as inputs, while a profile update flow processes user availability or skills. This flexibility ensures that workflows can adapt to the specific needs of each trigger while maintaining a clear separation of concerns between the frontend and backend.

The data from the front-end, often entered by the user, will be passed in the body or query parameters of the webhook call. Kestra’s trigger context makes this data available inside the flow (e.g., `{{ trigger.body.someField }}`). We will design our flows to accept necessary inputs (like user ID, job ID) either via the trigger payload or as formal **inputs** to the flow. Kestra flows can define input parameters with types and optional default values, ensuring the workflows know which user or job they are processing. For example, the job-posting flow might have an input schema for job details if triggered manually, but with a webhook, those details can be embedded directly.

### Auth0 for Authorization

Auth0 will help ensure that only authorized users can trigger certain flows. For instance, only users with the “publisher” role should be able to start the job-posting flow. The front-end can enforce this by only showing the job post UI to publishers, while the backend (Node.js or even a Kestra flow) can double-check roles if needed. This can be done by querying the user’s role from the database or decoding the JWT role claim. Kestra could perform a role check as a first task and abort or alert if a mismatch is detected, but for the POC, relying on front-end checks and Auth0 token claims is sufficient.

### Summary

Auth0 provides the **identity layer** and triggers for user events, while Kestra serves as the **automation layer**. The Vite PWA communicates with Kestra through secure HTTP calls (webhooks or API) to initiate automations in response to user actions. This decouples the front-end from performing long-running operations or complex logic, as Kestra handles these tasks asynchronously and robustly. Kestra’s event-driven nature, supporting webhook, schedule, and real-time event triggers, ensures immediate responses to user actions (e.g., job postings) while also enabling periodic maintenance tasks (e.g., “remind publishers of unfilled jobs every Monday”) using **Schedule triggers** if needed.

## Relevant Kestra Plugins and Workflow Definitions

To implement the above, we will utilize several **Kestra plugins and features**. Below is a summary of key ones relevant to our use case, along with pointers to Kestra documentation or examples:

**Webhook Triggers:** Allows flows to be initiated by an HTTP request from an external system. We will use this for most of our flows. *Reference:* Kestra docs on Webhook trigger explain the URL format and usage. Each flow YAML will include a trigger section like:

```yaml
triggers:
  - id: http_trigger
    type: io.kestra.core.models.triggers.types.Webhook
    key: "some-secret-key"
```

This generates the endpoint `.../webhook/{namespace}/{flowId}/some-secret-key` which the PWA/Auth0 calls.

**JDBC Database Plugin:** To avoid writing custom code for database access, we use Kestra's JDBC tasks. This plugin supports MySQL, PostgreSQL, etc., and enables executing SQL queries. We will use tasks of type `io.kestra.plugin.jdbc.postgresql.Query` (assuming Postgres) for selecting and inserting data. These tasks let us run arbitrary SQL and then use the results in subsequent tasks. For example, after a SELECT, the result rows are available as an array which we can loop over (Kestra supports looping via its YAML syntax or by using dynamic tasks).

**Notifications Plugin:** This provides tasks for various notification channels (Email, Slack, Twilio, etc.). Specifically, `MailSend` for SMTP emails, `SendGridMailSend` for SendGrid, and Twilio tasks for SMS are of interest. We have example YAML from Kestra's docs for sending an email which we can adapt to our SMTP server or use a service. Similarly, a Slack notification could be used internally – Kestra's blueprint for a vacation approval flow demonstrates sending a Slack message and waiting for a response. In our context, Slack could be used if we wanted an internal admin notification each time a job is posted (not essential for the POC).

**Script Execution (Optional):** If any matching logic is too complex for pure SQL (for example, if we wanted to use a custom algorithm to rank candidates), Kestra allows embedding code via script tasks. We can run a Python or Node.js snippet within the flow using the **Scripts plugin**. For instance, one could fetch candidates via SQL then use a Python task to sort or filter them by some advanced criteria. In the two-week timeframe, we'll likely stick to SQL and simple logic, but knowing this is possible means we can extend the matching capabilities without deploying separate microservices. Kestra's **"Code in Any Language"** feature (Python, R, Node, etc.) means we're not limited if requirements grow.

**Templates and Reusable Flows:** Kestra supports templates (reusable flow components) and subflows. If we notice repeated patterns (e.g., sending an email to a user), we could make a small reusable flow or template for it. Then our main flows could call those via a **Flow trigger** (one flow ending can trigger another flow) or a **SubFlow task**. Given our POC scope, we might not delve into templates, but it's good to note for future – e.g., a generic "notify user" flow could be triggered by various events.

**Blueprint Examples:** The Kestra documentation provides **blueprints** (pre-built example flows) that we can study or borrow from. For example, the *"Business process automation – vacation approval"* blueprint shows how user input, Slack messaging, and approval steps can be orchestrated. While our domain is different, the blueprint confirms Kestra's ability to handle multi-step workflows with human interaction. Another blueprint, *"Getting started – Business Automation workflow example,"* may illustrate typical tasks like sending notifications or calling external APIs. These can serve as references as we implement our own flows. Utilizing proven patterns from these templates will speed up development and ensure we follow best practices.

By combining these plugins and features, we effectively let Kestra act as our backend "glue," connecting the PWA front-end, the Auth0 identity provider, and the necessary data stores and communication channels. We emphasize that all of this is achieved through **configuration-as-code** (YAML) rather than lots of custom imperative code. This not only speeds up initial development but also makes it easier to maintain and adjust workflows as the business logic evolves (e.g., adding a new step to the matching algorithm is as simple as inserting a new task in the YAML and redeploying the flow).

## Two-Week Proof-of-Concept Plan

Below is a realistic timeline for a **14-day proof-of-concept (POC)** implementation of the above features using Kestra and the chosen tech stack. The goal of the POC is to demonstrate end-to-end functionality for the main user stories (register, post job, match, notify, apply) in a minimal but functional manner:

* **Week 1: Setup and Core Workflow Implementation**

  * *Days 1-2:* **Environment Setup** – Install and configure Kestra (likely using Docker for quick start). Set up a simple PostgreSQL (or MySQL) database for storing user and job data. Prepare Auth0 tenant (create application, define roles for seeker/publisher, and set up an Action for post-registration). Initialize the Vite PWA project if not already done. Verify that Auth0 authentication works in the PWA (users can log in/sign up) and that we can call a test backend endpoint with an Auth0 JWT.
  * *Days 3-4:* **Basic Flows in Kestra** – Create the **User Registration flow** in Kestra YAML. Hard-code or simulate a trigger initially (e.g., manually trigger it from Kestra UI with sample data) to test that it inserts a user record into the DB and sends a dummy welcome email (perhaps to a test email account or simply logs the email content). Adjust any credentials (SMTP settings, DB connection string) in the Kestra configuration or secrets store. Similarly, draft the **Job Posting flow**: define it with expected inputs (job title, skill, etc.), a manual trigger for now, and implement the DB insert and a dummy select query for candidates (we can insert a couple of fake user profiles to test the query). Ensure the flow runs in the Kestra UI and returns expected outputs (e.g., the list of matched user IDs).
  * *Days 5-7:* **Expand Workflows and Triggers** – Implement the **Profile/Availability Update flow** and **Job Application flow**. For the profile update, test it by manually invoking with a sample user ID and new availability data; verify the DB update and (if included) that the matching check returns appropriate results. For the application flow, simulate an application coming in and ensure an email to publisher (use a placeholder publisher email) is triggered. At this stage, focus on correctness of each flow’s logic (even if triggers are manual). By end of Week 1, we should have the four main workflows built and tested in isolation via the Kestra UI or API. We will also configure the **Webhook triggers** for each flow (generating URLs for later use). Documentation or inline comments will be added to each flow for clarity.

* **Week 2: Integration and Refinement**

  * *Days 8-9:* **Frontend Integration** – Modify the PWA (or create a minimal proxy backend) to call Kestra webhook URLs for each relevant action. For example, after Auth0 sign-up, the Auth0 Action will be configured to `POST` to the Kestra registration webhook with the new user’s info (this was prepared in Week 1; now we paste in the correct URL and deploy the Action). In the PWA, implement API calls: when the user saves their availability, call the Kestra profile update webhook; when a publisher posts a job via a form, on form submission call the job-posting webhook; and when a user clicks apply, call the application webhook. Because this is a POC, we can embed the webhook URLs in a config (noting that in a production scenario we’d secure this better or route through a server). Test each integration point one by one: e.g., create a test user via the PWA, observe in Kestra UI that the registration flow executed and an email was sent; post a new job via the PWA form, then check Kestra UI for the flow execution and see that candidates were found, etc. Debug any issues (like CORS problems, missing fields in payloads) during these days.
  * *Days 10-11:* **Notification Testing and Improvements** – Now that flows are connected, verify that emails/SMS are actually sending (if using a real email service or Twilio trial, etc., ensure credentials are set in Kestra secrets and tasks succeed). Tweak email content templates for clarity (for instance, include job title in subject, include relevant details in the body using Kestra template syntax). If any notifications are too spammy (e.g., maybe profile update flow sending an email for every small change), consider gating them (perhaps only send if a certain significant change occurred). Also, ensure that database changes made by flows are correctly reflected in the front-end. For example, after a job posting flow, we should be able to query the API (or directly the DB via a temporary UI) to see the candidate pool. If needed, create a simple endpoint or reuse Kestra’s outputs: Kestra can output data that the PWA could fetch via Kestra’s execution API, but it might be easier to just read from the DB. We might implement a quick endpoint in the PWA dev server to pull candidate suggestions from DB for display. These two days are about polishing the user experience loop – from action to outcome.
  * *Days 12-13:* **Proof-of-Concept Testing** – Conduct end-to-end tests of key scenarios:

    1. **New user onboarding:** User registers (Auth0), Kestra flow creates profile & sends welcome email. Verify in email inbox and database.
    2. **Profile update matching:** User updates skills/availability, Kestra checks for matches. If a sample job exists that should match, see that an email (or log) was produced. If none exists, no email – ensure no errors.
    3. **Job posting to notification:** Publisher (can use a test account flagged as publisher) posts a job through the UI form. Kestra flow runs: verify job is in DB, at least one test user was matched (we might create a dummy user beforehand with fitting skills to simulate this), and that an email was sent to that user (we can use a test email for the dummy user). Also verify the publisher got a summary email. Check the candidate\_pool table is populated correctly.
    4. **Application process:** As the dummy job seeker, apply to the job. Kestra flow runs: verify application in DB and publisher notification email received.
       Document any issues and fix them. Likely adjustments include handling edge cases (no candidates found, invalid data input – though in POC we might assume happy paths).
  * *Day 14:* **Buffer and Documentation** – Use the last day to catch up on anything unfinished, and to document the POC. We will prepare a short demo or screenshots of the flows in the Kestra UI (the graphical view of the workflow execution, for example) and outline instructions to run the demo. We also write up notes on limitations and next steps (e.g., what we would do in a full product: add push notifications, refine matching criteria, implement proper UI for candidate pools, etc.). This documentation, along with the flows YAML, will be delivered as part of the POC.

This two-week plan focuses on delivering a vertical slice of functionality rather than perfecting every detail. Some trade-offs for the POC include using simple matching logic (exact skill tag match, availability as a broad flag), using basic notifications (one channel, no localization or HTML fanciness), and minimal front-end polish (the PWA forms will be functional but not fully styled or validated). The emphasis is on proving that Kestra can **glue together the system**: when an event happens on the front-end, the correct backend workflows execute, modify data, and send out notifications, without the need to write custom servers for each workflow.

## Division of Responsibilities: Frontend vs. Kestra Backend

The following table summarizes how responsibilities are split between the Vite PWA frontend (plus Auth0 for identity) and the Kestra orchestrator for each major workflow:

| **Workflow / Event**            | **Frontend (PWA & Auth0)**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | **Kestra Backend (Flows & Tasks)**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **User Registration**           | User signs up via Auth0 (provides email, password, etc.). Auth0 handles authentication and immediately logs in the user. Auth0 **Post-Registration Action** is configured to call the Kestra webhook with the new user’s details.                                                                                                                                                                                                                                                                                                            | Receives trigger from Auth0 Action. Executes **Registration Flow**: creates user profile in app database (with Auth0 user ID), sets default role (seeker/publisher as appropriate), and sends a welcome email to the user. All done asynchronously right after Auth0 sign-up, without user intervention.                                                                                                                                                                                                                                                                                                                                                                                                                             |
| **Profile/Availability Update** | User (seeker) updates their profile info or availability through a form in the PWA (e.g., selecting dates available, adding a skill tag). The PWA, after ensuring the user is authenticated (valid JWT), sends an HTTP request to the **Kestra webhook** for the update flow (or to a backend endpoint which forwards to Kestra).                                                                                                                                                                                                            | The **Profile Update Flow** updates the user’s record in the database (new availability schedule, skill set). It then optionally runs a **matching query**: finds any currently open jobs that fit the new profile. If matches are found, it triggers notifications (e.g., sends the user an email with a list of matching jobs or marks those jobs for the user to review later). If no matches, the flow can simply complete with no notifications (or perhaps log that no jobs match yet).                                                                                                                                                                                                                                        |
| **Job Posting**                 | Job publisher fills out a “Post a Job” form in the PWA (job title, description, required skills, location, dates, etc.). On submission, the PWA sends the job data along with the publisher’s ID (from Auth0 token) to the Kestra job-posting webhook. The PWA may show the publisher a “Job is being posted...” status and will later allow viewing of the candidate matches.                                                                                                                                                               | The **Job Posting Flow** records the new job in the database (via an insert task). It then immediately performs **automated matching**: querying the user profiles to find all seekers qualified and available for this job. The flow compiles the **Candidate Pool** (e.g., 10 users found). It then sends out notifications: potentially an email to each matching seeker (“New job posted: \[Job Title] matches your profile”) and an email to the publisher summarizing the results (“Your job has 10 potential candidates, notifications sent”). The flow could also save the list of candidate user IDs in a `candidate_pool` table for the frontend to fetch. All these steps occur within seconds after the form submission. |
| **Candidate Pool Access**       | After posting a job, the publisher can view the job details in the PWA (maybe on a “Job Dashboard” page). When this page loads, the PWA requests the list of matched candidates from the backend. (In the POC, we might have a simple API that reads the `candidate_pool` table or we reuse Kestra outputs if accessible via API.) The PWA then displays the candidate list (names, contacts, etc.) to the publisher.                                                                                                                        | (Indirect role) The candidate pool was already generated by the job posting flow. Kestra ensured the data was stored in the database. There isn’t a specific “pool flow” the user triggers; rather, it’s a product of the posting flow. However, we could have a separate flow if we wanted to periodically refresh candidate pools or if the matching process were decoupled. In the POC, the heavy lifting (finding matches) is done at job post time by Kestra. The retrieval of that info is a simple DB query by the front-end (or it could be a Kestra-triggered API call if we set one up).                                                                                                                                   |
| **Job Application**             | A job seeker applies to a job via the PWA (clicks “Apply” and maybe writes a message). The PWA sends the application data to a protected endpoint. This could directly be a Kestra webhook for the application flow, including the job ID, user ID, and message. The frontend might instantly show “Application sent” to the user, while backend processing continues.                                                                                                                                                                       | The **Application Flow** records the application in the database (creates an application entry linking seeker and job). It then **notifies the job publisher** (e.g., via email: “John Doe has applied to your job \[Job Title]. Log in to view their profile.”). Optionally, it can send a confirmation email to the applicant. This flow may also update any in-memory or cached lists of applicants (for real-time UI updates, though in POC we might skip live updates). Kestra ensures the publisher is promptly alerted and the data is consistent (no need for the front-end to do additional work beyond triggering the flow).                                                                                               |
| **Notifications & Alerts**      | The PWA will eventually include an inbox or notification center for users, but in the POC the PWA itself is not generating notifications – it relies on backend communications. The only front-end responsibility is to possibly inform the user to check their email or to reflect changes (e.g., show a job as “applied” after they apply, which it can do by trusting that after it called the apply flow, the application was recorded). For real-time feedback, the front-end might poll or receive a webhook (not implemented in POC). | Kestra handles all **notification logic** within flows. It sends emails or texts as needed when triggers occur (match found, application received, etc.). It also could handle scheduled reminders (not in current scope, but e.g., a daily flow to remind users of expiring opportunities could be scheduled via Kestra’s cron trigger). Essentially, all user or publisher communication events are orchestrated by Kestra tasks (Mail, Twilio, etc.), ensuring consistent messaging. The front-end does not send emails or reach out to users directly; it delegates that to the backend workflows.                                                                                                                               |

*(Table: Division of responsibilities between the Vite.js PWA frontend and the Kestra orchestrated backend for each major workflow.)*

## Conclusion

By utilizing Kestra.io as the backend workflow engine, we create a clear separation of concerns in our PWA architecture. The **frontend** (with Auth0) handles user interactions, input collection, and UI feedback, while delegating heavy processing and decision-making to **Kestra workflows**. Kestra’s event-driven orchestration ensures that whenever a significant event occurs (a new user, a new job, an application), the right sequence of automated steps is executed reliably – updating databases, performing match logic, and sending notifications. This results in a system where much of the business logic is centralized in easily maintainable YAML definitions, benefiting from Kestra’s scalability and observability (we can monitor flows, handle errors with retries, etc., out-of-the-box).

In just a two-week proof of concept, we can implement the core matching platform features: **automated matching** of job seekers to jobs based on skills and availability, and **instant communication** of those matches to both parties. Kestra’s extensive plugin library and triggers have been key in achieving this quickly – we avoided writing custom glue code for database access or email sending, and instead leveraged declarative tasks. Moving forward, this architecture can be extended (for example, adding **real-time PWA notifications** via WebSocket triggers or integrating additional services like mapping APIs to match by location). The PWA, Auth0, and Kestra integration demonstrated in the POC lays a solid foundation for a scalable job matching service where adding new workflows (such as a “rate the employee” flow after a job is done) would be as straightforward as writing a new Kestra YAML and hooking up a trigger.

Overall, Kestra proves to be a powerful **orchestration backbone** for our application – enabling rapid development of complex backend workflows while keeping the frontend lightweight and responsive to user needs.&#x20;
